### FEATURE EXPECTATIONS [5 min]
- Functional Requirements: Use cases
- Non-functional Requirements: latency, scalability, availability, durability, consistency, reliability
### ESTIMATIONS [5 min]
- Throughput (QPS for read and write queries)
- Latency expected from the system (for read and write queries)
- Read/Write ratio
- Traffic estimates
  - Write (QPS, Volume of data)
  - Read  (QPS, Volume of data)
- Storage/memory estimates
  - entitys - user, records, metadata, etc
  - static - image, video, text, etc..
### DESIGN GOALS [5 min]
- CAP Theorem: Consistency vs Availability  
  - partitioning - network failure
  - availability - latency, peak usage
  - consistency - data in transaction, likes, follows, etc..
### HIGH LEVEL DESIGN [5-10 min]
- APIs for Read/Write scenarios for crucial components
- Database choice: relational vs. noSQL vs. combined, ACID(consistency) vs BASE(availability)
  - relational - relation, complex query, sharding-partitioning
  - noSQL - speed, horizontal scaling, low consistency, unstrunctured data
- blob storage - video/image,
- Database schema
  - sharding for follower, friend, timeseries..
- Basic algorithm
- diagrams
  - API gateway: authentication, security, rate limiting, throttling, transformations, analytics and monitoring
  - load balancer
  - servers (for search (elastic search), auth, update, etc..
  - CDN,
  - pub-sub redis
  - queue
### DEEP DIVE [15-20 min]
- focuses:
  - instagram:
    - gen timeline: pull(many followerrs) vs push(few followerd), use hybrid
    - ranking service, notification
  - whatsapp:
    - websocket : userA - socket - socketManager - socket - userB
    - queueing  - kafka
    - group service: fetches all user info from db/cache, deliever to each user's socket
    - send message: put message into cache (if receiver offline)
    - get message: get message from cache (when receiver comeback online) and delete after 30days
    - upload / download files
  - newsfeed:
    - post generation steps, generates on request for inactive users & pre-generates for active users.  put into cache
    - post publishing steps, fetches from cache then fan-out(pull push)
    - ranking service - frequenty interacts, time spent, filter bad, past history.. db ranking score, relavent score
  - online judge:
    - contest(time stricted), submissions, problems, like comments, leaderboard
    - test processor - queue
- Scaling individual components: 
  - Availability, Consistency and Scale story for each component
  - Consistency and availability patterns
- data availability - with built-in redundent storage and frequent backup - AWS RDS/Dynamono
- replication - master slave on relational DB, multi-region for noSQL DB
- Think about the following components, how they would fit in and how it would help
  - DNS
  - CDN [Push vs Pull]
  - Load Balancers [Active-Passive, Active-Active, Layer 4, Layer 7]
  - Reverse Proxy
  - Application layer scaling [Microservices, Service Discovery]
  - DB [RDBMS, NoSQL]
   - RDBMS 
     - Master-slave, Master-master, Federation, Sharding, Denormalization, SQL Tuning
   - NoSQL
     - Key-Value, Wide-Column, Graph, Document
       - Fast-lookups:
         - RAM  [Bounded size] => Redis, Memcached
         - AP [Unbounded size] => Cassandra, RIAK, Voldemort
         - CP [Unbounded size] => HBase, MongoDB, Couchbase, DynamoDB
   - Caches
     - Client caching, CDN caching, Webserver caching, Database caching, Application caching, Cache @Query level, Cache @Object level
     - Eviction policies:
      - Cache aside
      - Write through
      - Write behind
      - Refresh ahead
  - Asynchronism
    - Message queues
    - Task queues
    - Back pressure
  - Communication
    - TCP
    - UDP
    - REST
    - RPC
### JUSTIFY [5 min]
- Throughput of each layer
- Latency caused between each layer
- Overall latency justification
